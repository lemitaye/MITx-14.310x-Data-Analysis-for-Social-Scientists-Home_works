---
title: 'Module 3: Home Work'
author: "Lemi Daba"
date: "10/14/2020"
output: 
  github_document:    
    pandoc_args: --webtex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preamble

In this problem set we will guide you through different ways of accessing real data sets and how to summarize and describe it properly. First we will go through some of the data that is collected by the World Bank. We will do some cleaning on the data before we start analyzing it. Then, we will try to do a simple web scraping exercise where we will analyze the data as well.


Let’s start with this dataset from the World Bank.  Please download and save this file in a folder where you can get it easily.

This dataset is a truncated version of one you can find on the [World Bank Gender Statistics website](https://datacatalog.worldbank.org/dataset/gender-statistics). You may visit the website and explore other datasets they offer. **However, for the purposes of this assignment, please use the file in this set of instructions**, since the dataset on the World Bank website may have been updated in the time since this problem set and answer key was posted.

**NOTE**:  It is important to work in the same directory that the files are or to use the whole path when you specify opening a data set. To know which directory you are currently working in, you can use the command `getwd()`. Similarly, in order to set a different directory, you can use the command `setwd()`.

For the purpose of analyzing the data, we are going to use the packages **utils** and **tidyverse**. Once you have uploaded the data to R you are going to see there are multiple indicators of gender, countries and years in the data. In this case we are just interested in analyzing the data for one indicator that is the *Adolescent Fertility Rate*, in the data the indicator code for this variable is called SP.ADO.TFRT . This indicator measures the annual number of births to women 15 to 19 years of age per 1,000 women in that age group. It represents the risk of childbearing among adolescent women 15 to 19 years of age. It is also referred to as the age-specific fertility rate for women aged 15-19. Once you have completed this problem set you’ll have more information of how this rate has evolved over time and how it varies across different groups of countries.

Take a look at the following lines of code, whose main purpose is to upload the data in a data frame and to choose the proper indicator. Please, try to understand the code and then run it in your computer. Remember to set the directory accordingly to the folder where you saved the files.

```
#Preliminaries
rm(list=ls())
library("utils")
library("tidyverse")

setwd("-----------")

#Getting the data
gender_data <- as_tibble(read.csv("Gender_StatsData.csv"))
```

**Using the code, answer the following questions:**

## Question 1

What is the purpose of the line `rm(list = ls())`?

### Answer

This command removes all current objects in the Global Environment. It is usually useful when we want to start a new analysis with a clean slate. 


## Question 2

The first thing you want to figure out when you look at a new dataset is how it is organized. If your dataset is stored as a tibble, you can simply print the object and it will print in a nice-looking format.

Alternatively, you can also use the built-in R commands such as `str()`, which allows you to see the structure of an object in R. Likewise, the commands `head()` and `tail()` will allow you to see the first six and last six observations of your data frame respectively. Another useful function is the function `dim()`, which will give you the number of rows and columns in your dataset. Take the time to explore the data using these commands and others.

Which of the following statements best describes how your data is organized? Note that we use "indicator" to mean something that is being measured (e.g. fertility rate, enrollment rate, etc.).


### Answer

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(utils)

gender_data <- read_csv("Gender_StatsData.csv")
```

With tibbles we can view the first few observations without using `head()`:
```{r}
gender_data
```

(We can get a more exteded view with `View(gender_data)` in RStudio.) Here, let's use knitr's `kable` command to get a nice formatted tabular view of the first 15 observations in our data.

```{r}
knitr::kable(gender_data[1:15, ])
```

It seems each observation corresponds to a country-indicator combination. To confirm our suspicion, let's count the observations in each country-indicator combination and see if any of them contain more than one observation:

```{r}
gender_data %>%
  count(Country.Code, Indicator.Code) %>%
  filter(n > 1)
```

There are 0 groups with more than 1 observation in them. So the variables `Country.Code` and `Indicator.Code` do indeed uniquely identify each observation. 


## Question 3

Now, generate a tibble called "`teenager_fr`”, which contains only the adolescent fertility rate indicator for each country-year. Please fill in the blank with the correct code.

### Answer

```{r}
teenager_fr <- filter(
  gender_data,
  Indicator.Code == "SP.ADO.TFRT"
)

teenager_fr
```


## Question 3 (continued)

What is the equivalent base-R function ? (select one)

(Choices are not shown here.)


### Answer

Out of the three alternatives presented, `subset()` is the equivalent base-R function to dplyr's `filter()`. The following code gives the same result as using `filter()` above. 

```{r}
subset(gender_data, Indicator.Code == "SP.ADO.TFRT")
```


`which()` returns the position of the elements (i.e., row number/column number/array index) in a logical vector which are TRUE, whereas `match()` returns the position of first occurrence of its first argument in its second.


## Question 4

Since we are not interested in any other variables and the gender_data dataset is quite large, you might want to get rid of it instead of asking R to keep it stored in memory.

Which of the following is the correct code for getting rid of the object `gender_data`?

(Choices are not displayed here.)


### Answer

Use `rm()` to remove objects from the global environment. So `rm(gender_data)` achieves the desired result.


## Part 1: Questions 5-8

Now that you have loaded the data we want to analyze and have familiarized yourself with the structure, it is time to get our hands dirty!

A second exploratory thing to do once we have organized a data set is to get basic summary statistics of the data. Now let’s do this! To print summary statistics directly in your console, you can use any of the basic summary functions in R (`mean()`, `sd()`, `min()`, `max()`, `sum()` ...). The basic summary functions take vectors as an input, and output a single value.

For example, if you were interested in obtaining the sample mean of the Adolescent Fertility Rate in 1975, one way of doing this is as follows:

```
mean(teenager_fr$X1975, na.rm = TRUE)
```

## Question 5

Why it is necessary to add the option `na.rm = TRUE` to the above command? (Select all that apply)

(Choice are not shown here.)

### Answer

The `na.rm` argument removes missing (`NA`) values while applying the function to compute summary statistics. In R, the default value for this argument is `FALSE` which means R does not remove missing values when applying the function. This was done for safety reasons because missing values are important and it’s a bad idea to silently ignore missing values by default (See Wickham and Grolemund (2017)). The downside is that if there is even a single missing value in our data, the function returns `NA`, because any computation with missing values produces a missing value. 

---

To calculate summary statistics for a group of variables, there are a few different commands. The command `mean()` is just one example of the different options available. Now, we ask you to go through the R documentation and explore some of the other commands by yourself.

If you want to store the output as values in your dataset, or if you want to do something more complicated (ex. Generate these by group, or use one of the dplyr summary functions (ex. `n_distinct()`), you can use any of the basic summary functions as well as others, in combination with `mutate()` and `summarise()` to generate variables in your dataset containing summary values.

Now that you’ve learned how to look at and generate summary statistics, answer the following questions.

---

## Question 6

What is the sample mean and standard deviation of the adolescent fertility rate in 1960?

*Please round your answers to the second hundredth decimal place, i.e. if your answer is 2.356, round it to 2.36.*

### Answer

```{r}
mean_fr_1960 <- mean(teenager_fr$X1960, na.rm = TRUE) %>% round(2)
cat("Sample mean of FR in 1960: ", mean_fr_1960)
```

```{r}
sd_fr_1960 <- sd(teenager_fr$X1960, na.rm = TRUE) %>% round(2)
cat("Standard deviation of FR in 1960: ", sd_fr_1960)
```

## Question 7

What is the sample mean and standard deviation of the adolescent fertility rate in 2000?

*Please round your answers to the second hundredth decimal place, i.e. if you answer is 2.356 round it 2.36.*

### Answer

```{r}
mean_fr_2000 <- mean(teenager_fr$X2000, na.rm = TRUE) %>% round(2)
cat("Sample mean of FR in 2000: ", mean_fr_2000)
```

```{r}
sd_fr_2000 <- sd(teenager_fr$X2000, na.rm = TRUE) %>% round(2)
cat("Standard deviation of FR in 2000: ", sd_fr_2000)
```


## Question 8

True or False? Based on the results from Questions 6 and 7, we can conclude that the Adolescent Fertility Rate has had a permanent decreasing (i.e. only decreases and never increases during this period) trend from 1960-2000, and that the dispersion of this variable has decreased over time.

### Answer

Based on the observations at the two points in time (1960 and 2000) alone, we cannot conclude that there was a decreasing or an increasing trend. So the answer is false.

---

Now, we are interested in plotting the evolution of the Adolescent Fertility Rate from 1960 to 2015. In addition, we are interested in having different information in the same plot. First, we want to plot the sample mean of all the data set, but also we want to add more information such as the rate for low, middle and high income countries (an indicator for country code is stored in the variable "`Country.Code`").

Inspect this variable to get a sense of what it contains. Note that it includes indicators for both countries, regions, and income group.  Since we are only interested in the trends by income group, we want to filter the data to contain only the fertility rate for high, middle, and low income countries as well as the world average.

---

## Question 9

Use the dplyr `filter()` command and the logical `%in%` to keep only the relevant `Country.Code` observations in `teenager_fr.` Make sure you name the new dataset “`byincomelevel`”. Choose the line of code below:

(Choices are not shown here.)

### Answer

(Based on the choices provided.)

```{r}
byincomelevel <- filter(teenager_fr, Country.Code %in% c("LIC", "MIC", "HIC", "WLD") )

byincomelevel
```

---

Notice, there are still two problems with the resulting data:

1. It contains additional variables that we don't need or are meaningless at this level of aggregation.

2. It is not organized in a very intuitive way.  A more natural way to organize this data, and prepare it for plotting, is to have each observation represent either a year or a country group-year, and each of the columns represent either the fertility rate for a given group, or if the data is at the country-group year level, then just the fertility rate.

---

## Question 10

Suppose you decide you prefer to have one observation per income group and year. The tidyr command `gather()` can help you achieve this. Look up the command in the help files. Select the set of arguments that belong in the blanks below.

### Answer

(Based on the code given in the question.)

```{r}
plotdata_bygroupyear <- gather(byincomelevel, Year, FertilityRate, X1960:X2015) %>%
  select(Year, Country.Name, Country.Code, FertilityRate)

plotdata_bygroupyear
```

An alternative and more recent approach to do this is using the tidyr `pivot_longer()` function. 

```{r}
byincomelevel %>% 
  pivot_longer(X1960:X2015, names_to = "Year", values_to = "FertilityRate") %>%
  select(Year, Country.Name, Country.Code, FertilityRate) %>% 
  arrange(Year)
```





















